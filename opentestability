#!/usr/bin/env python3
"""
OpenTestability CLI - Interactive Command Environment

A comprehensive framework for gate-level testability analysis.
This script provides an easy-to-use interface without needing to type 'python3' every time.

Usage:
    ./opentestability <command> [options]
    
Commands:
    parse       Parse Verilog netlist to internal format
    scoap       Compute SCOAP testability metrics  
    dag         Build DAG representation from parsed netlist
    graph       Generate graph visualization from DAG
    reconverge  Detect reconvergent fanout structures
    help        Show detailed help and examples
    commands    List all available commands
    workflow    Show complete analysis workflow
    status      Show project status and file counts
    
Examples:
    ./opentestability parse design.v output.txt
    ./opentestability scoap input.txt results.txt --json
    ./opentestability help parse
    ./opentestability workflow
"""

import argparse
import sys
import os
from pathlib import Path

# Add src directory to Python path for imports
SCRIPT_DIR = Path(__file__).parent
SRC_DIR = SCRIPT_DIR / 'src'
sys.path.insert(0, str(SRC_DIR))

from opentestability.parsers.verilog_parser import parse as run_parse
from opentestability.parsers.json_converter import convert_txt_to_json
from opentestability.core.scoap import run as run_scoap
from opentestability.core.dag_builder import create_dag_from_netlist
from opentestability.core.reconvergence import analyze_reconvergence
from opentestability.visualization.graph_renderer import visualize_gate_graph
from opentestability.utils.file_utils import get_project_paths


def print_banner():
    """Print the OpenTestability banner."""
    banner = """
╔══════════════════════════════════════════════════════════════╗
║                    🔬 OpenTestability                        ║
║              Gate-Level Testability Analysis                 ║
║                                                              ║
║  SCOAP • Reconvergence • Visualization • DFT Analysis       ║
╚══════════════════════════════════════════════════════════════╝
    """
    print(banner)


def show_commands():
    """Show all available commands with descriptions."""
    print("\n📋 Available Commands:\n")
    commands = {
        "parse": "Parse Verilog netlist to internal text format",
        "scoap": "Compute SCOAP controllability/observability metrics",
        "dag": "Build DAG representation from parsed netlist JSON",
        "graph": "Generate graph visualization from DAG JSON",
        "reconverge": "Detect reconvergent fanout structures in DAG",
        "help": "Show detailed help for specific commands",
        "commands": "List all available commands (this list)",
        "workflow": "Show complete analysis workflow with examples",
        "status": "Show project status and file counts"
    }
    
    for cmd, desc in commands.items():
        print(f"  {cmd:12} - {desc}")
    
    print(f"\nUsage: ./opentestability <command> [options]")
    print(f"       ./opentestability help <command>  # For detailed help")


def show_workflow():
    """Show the complete analysis workflow."""
    print("\n🔄 Complete Analysis Workflow:\n")
    
    workflow_steps = [
        ("1. Parse", "./opentestability parse priority_encoder.v priority_enc.txt --json"),
        ("2. SCOAP", "./opentestability scoap priority_enc.txt scoap_results.txt --json"),
        ("3. DAG", "./opentestability dag priority_enc.json"),
        ("4. Graph", "./opentestability graph priority_enc_dag.json"),
        ("5. Reconvergence", "./opentestability reconverge priority_enc_dag.json")
    ]
    
    for step, command in workflow_steps:
        print(f"  {step:15} {command}")
    
    print(f"\n📁 Files will be organized in:")
    print(f"  data/input/       - Input Verilog netlists")
    print(f"  data/parsed/      - Parsed text and JSON files")
    print(f"  data/results/     - SCOAP analysis results")
    print(f"  data/dag_output/  - DAG JSON representations")
    print(f"  data/graphs/      - PNG visualizations")
    print(f"  data/reconvergence_output/ - Fanout analysis")


def show_status():
    """Show project status and file counts."""
    print("\n📊 Project Status:\n")
    
    paths = get_project_paths()
    
    status_info = [
        ("Input netlists", paths['input']),
        ("Parsed files", paths['parsed']),
        ("SCOAP results", paths['results']),
        ("DAG files", paths['dag_output']),
        ("Visualizations", paths['graphs']),
        ("Reconvergence analysis", paths['reconvergence_output'])
    ]
    
    for name, path in status_info:
        if path.exists():
            file_count = len([f for f in path.iterdir() if f.is_file()])
            print(f"  {name:25} {file_count:3d} files")
        else:
            print(f"  {name:25}   - (directory not found)")


def show_command_help(command):
    """Show detailed help for a specific command."""
    help_text = {
        "parse": """
📝 Parse Command - Convert Verilog netlists to internal format

Usage: ./opentestability parse <input.v> <output.txt> [--json]

Arguments:
  input.v       Input Verilog netlist file (in data/input/)
  output.txt    Output parsed text file (saved to data/parsed/)
  --json        Also generate JSON version of parsed file

Examples:
  ./opentestability parse priority_encoder.v priority_enc.txt
  ./opentestability parse design.v parsed_design.txt --json

Input:  data/input/<input.v>
Output: data/parsed/<output.txt>
        data/parsed/<output.json> (if --json)
        """,
        
        "scoap": """
📊 SCOAP Command - Compute testability metrics

Usage: ./opentestability scoap <input.txt> <output.txt> [--json]

Arguments:
  input.txt     Parsed netlist file (from data/parsed/)
  output.txt    Output results file (saved to data/results/)
  --json        Also generate JSON version of results

Examples:
  ./opentestability scoap priority_enc.txt scoap_results.txt
  ./opentestability scoap parsed_design.txt analysis.txt --json

Computes:
  CC0 - Controllability to logic 0
  CC1 - Controllability to logic 1  
  CO  - Observability

Input:  data/parsed/<input.txt>
Output: data/results/<output.txt>
        data/results/<output.json> (if --json)
        """,
        
        "dag": """
🌐 DAG Command - Build directed acyclic graph representation

Usage: ./opentestability dag <input.json>

Arguments:
  input.json    Parsed netlist JSON file (from data/parsed/)

Examples:
  ./opentestability dag priority_enc.json
  ./opentestability dag parsed_design.json

Creates DAG structure for:
  - Reconvergence analysis
  - Graph visualization
  - Structural analysis

Input:  data/parsed/<input.json>
Output: data/dag_output/<input>_dag.json
        """,
        
        "graph": """
📈 Graph Command - Generate circuit visualization

Usage: ./opentestability graph <dag.json>

Arguments:
  dag.json      DAG JSON file (from data/dag_output/)

Examples:
  ./opentestability graph priority_enc_dag.json
  ./opentestability graph design_dag.json

Generates:
  - PNG visualization using Graphviz
  - Color-coded nodes (inputs, outputs, gates)
  - Circuit structure diagram

Input:  data/dag_output/<dag.json>
Output: data/graphs/<name>_graph.png
        """,
        
        "reconverge": """
🔀 Reconverge Command - Detect reconvergent fanout structures

Usage: ./opentestability reconverge <dag.json>

Arguments:
  dag.json      DAG JSON file (from data/dag_output/)

Examples:
  ./opentestability reconverge priority_enc_dag.json
  ./opentestability reconverge design_dag.json

Identifies:
  - Reconvergent fanout points
  - Multiple paths between nodes
  - Critical structures for test coverage

Input:  data/dag_output/<dag.json>
Output: data/reconvergence_output/<name>_reconv.json
        """
    }
    
    if command in help_text:
        print(help_text[command])
    else:
        print(f"\n❌ Unknown command: {command}")
        print("Available commands: parse, scoap, dag, graph, reconverge")


def check_file(path):
    """Check if a file exists and report status."""
    if not Path(path).exists():
        print(f"❌ Input file not found: {path}")
        sys.exit(1)
    print(f"✅ Found input file: {path}")


def main():
    """Main CLI entry point."""
    if len(sys.argv) < 2:
        print_banner()
        show_commands()
        print(f"\nUse: ./opentestability help <command> for detailed help")
        print(f"     ./opentestability workflow for complete workflow")
        sys.exit(0)
    
    command = sys.argv[1].lower()
    
    # Handle special commands
    if command in ['help', '-h', '--help']:
        if len(sys.argv) > 2:
            show_command_help(sys.argv[2])
        else:
            print_banner()
            show_commands()
        return
        
    elif command == 'commands':
        show_commands()
        return
        
    elif command == 'workflow':
        show_workflow()
        return
        
    elif command == 'status':
        show_status()
        return
    
    paths = get_project_paths()
    
    try:
        if command == 'parse':
            if len(sys.argv) < 4:
                print("❌ Usage: ./opentestability parse <input.v> <output.txt> [--json]")
                sys.exit(1)
                
            input_file = sys.argv[2]
            output_file = sys.argv[3]
            json_flag = '--json' in sys.argv
            
            input_path = paths['input'] / input_file
            check_file(input_path)
            
            print("🔄 Running Verilog parser...")
            output_path = run_parse(input_file, output_file)
            print(f"✅ Parsed netlist saved to: {output_path}")
            
            if json_flag:
                print("🔄 Converting to JSON format...")
                json_path = convert_txt_to_json(output_file)
                print(f"✅ JSON format saved to: {json_path}")

        elif command == 'scoap':
            if len(sys.argv) < 4:
                print("❌ Usage: ./opentestability scoap <input.txt> <output.txt> [--json]")
                sys.exit(1)
                
            input_file = sys.argv[2]
            output_file = sys.argv[3]
            json_flag = '--json' in sys.argv
            
            input_path = paths['parsed'] / input_file
            check_file(input_path)
            
            print("🔄 Running SCOAP analysis...")
            output_path = run_scoap(input_file, output_file, json_flag=json_flag)
            print(f"✅ SCOAP results saved to: {output_path}")
            
            if json_flag:
                json_name = Path(output_file).stem + ".json"
                json_path = paths['results'] / json_name
                print(f"✅ SCOAP JSON saved to: {json_path}")

        elif command == 'dag':
            if len(sys.argv) < 3:
                print("❌ Usage: ./opentestability dag <input.json>")
                sys.exit(1)
                
            input_file = sys.argv[2]
            input_path = paths['parsed'] / input_file
            check_file(input_path)
            
            print(f"🔄 Building DAG from: {input_path}")
            output_path = create_dag_from_netlist(input_file)
            print(f"✅ DAG JSON saved to: {output_path}")

        elif command == 'graph':
            if len(sys.argv) < 3:
                print("❌ Usage: ./opentestability graph <dag.json>")
                sys.exit(1)
                
            input_file = sys.argv[2]
            input_path = paths['dag_output'] / input_file
            check_file(input_path)
            
            print(f"🔄 Rendering graph visualization from: {input_path}")
            output_path = visualize_gate_graph(input_file)
            print(f"✅ Graph visualization saved to: {output_path}")

        elif command == 'reconverge':
            if len(sys.argv) < 3:
                print("❌ Usage: ./opentestability reconverge <dag.json>")
                sys.exit(1)
                
            input_file = sys.argv[2]
            input_path = paths['dag_output'] / input_file
            check_file(input_path)
            
            print(f"🔄 Analyzing reconvergent fanout from: {input_path}")
            output_path = analyze_reconvergence(input_file)
            print(f"✅ Reconvergence analysis saved to: {output_path}")

        else:
            print(f"❌ Unknown command: {command}")
            print("Available commands: parse, scoap, dag, graph, reconverge, help, commands, workflow, status")
            sys.exit(1)

        print("🎉 Operation completed successfully!")

    except FileNotFoundError as e:
        print(f"❌ File not found: {e}")
        sys.exit(1)
    except Exception as e:
        print(f"❌ Error: {e}")
        sys.exit(1)


if __name__ == "__main__":
    main()