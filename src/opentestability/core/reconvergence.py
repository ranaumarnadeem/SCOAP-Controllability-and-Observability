"""
Reconvergent fanout detection for testability analysis.

This module identifies reconvergent fanout structures in digital circuits,
which are critical for understanding fault propagation and test coverage.
"""

import json
import os
import sys
import networkx as nx
from itertools import combinations
from collections import deque
from pathlib import Path

from ..utils.file_utils import get_project_paths, ensure_directory


def load_dag_json(dag_filename):
    """
    Load a DAG JSON file.
    
    Args:
        dag_filename: Name of DAG JSON file in data/dag_output/
        
    Returns:
        Dictionary containing DAG data
        
    Raises:
        FileNotFoundError: If DAG file doesn't exist
    """
    paths = get_project_paths()
    dag_path = paths['dag_output'] / dag_filename
    
    if not dag_path.exists():
        raise FileNotFoundError(f"DAG JSON not found: {dag_path}")
    
    with open(dag_path, 'r') as f:
        return json.load(f)


def build_dag_graph(dag_data):
    """
    Build NetworkX directed graph from DAG data.
    
    Args:
        dag_data: Dictionary containing DAG edges and labels
        
    Returns:
        NetworkX DiGraph object
    """
    G = nx.DiGraph()
    G.add_edges_from(dag_data['edges'])
    return G


def break_cycles(G):
    """
    Remove back-edges to make the graph acyclic.
    
    Args:
        G: NetworkX DiGraph that may contain cycles
        
    Note:
        Modifies the graph in-place by removing cycle-forming edges.
    """
    try:
        while True:
            cycle = nx.find_cycle(G, orientation='original')
            u, v, _ = cycle[-1]
            G.remove_edge(u, v)
            print(f"[WARN] Removed cycle edge {u} -> {v}")
    except nx.NetworkXNoCycle:
        pass


def find_fanout_points(G):
    """
    Find all fanout points (nodes with out-degree > 1).
    
    Args:
        G: NetworkX DiGraph
        
    Returns:
        List of node names that are fanout points
    """
    return [n for n in G.nodes if G.out_degree(n) > 1]


def bfs_path(G, source, target, max_depth=20):
    """
    Find a path from source to target using BFS.
    
    Args:
        G: NetworkX DiGraph
        source: Source node
        target: Target node
        max_depth: Maximum path length to search
        
    Returns:
        List representing the path, or None if no path found
    """
    queue = deque([[source]])
    
    while queue:
        path = queue.popleft()
        
        if path[-1] == target:
            return path
            
        if len(path) >= max_depth:
            continue
            
        for nxt in G.successors(path[-1]):
            if nxt not in path:
                queue.append(path + [nxt])
    
    return None


def find_reconvergences(G):
    """
    Find all reconvergent fanout structures in the graph.
    
    Args:
        G: NetworkX DiGraph
        
    Returns:
        List of reconvergence dictionaries, each containing:
        - site: The reconvergence point
        - branch1, branch2: The two fanout sources
        - path1, path2: The reconvergent paths
    """
    fanouts = find_fanout_points(G)
    results = []
    
    for site in G.nodes:
        # Find all fanout points that can reach this site
        sources = [f for f in fanouts if nx.has_path(G, f, site)]
        
        # Check all pairs of sources for reconvergence
        for a, b in combinations(sources, 2):
            p1 = bfs_path(G, a, site)
            p2 = bfs_path(G, b, site)
            
            if p1 and p2:
                # Check if paths are disjoint (true reconvergence)
                if set(p1[1:-1]).isdisjoint(p2[1:-1]):
                    results.append({
                        'site': site,
                        'branch1': a,
                        'branch2': b,
                        'path1': p1,
                        'path2': p2
                    })
    
    return results


def save_reconvergence(data, output_filename):
    """
    Save reconvergence data to JSON file.
    
    Args:
        data: Reconvergence analysis results
        output_filename: Name of output file
        
    Returns:
        Path to the saved file
    """
    paths = get_project_paths()
    ensure_directory(paths['reconvergence_output'])
    output_path = paths['reconvergence_output'] / output_filename
    
    with open(output_path, 'w') as f:
        json.dump(data, f, indent=2)
    
    print(f"[✓] Reconvergence analysis saved to {output_path}")
    return str(output_path)


def analyze_reconvergence(dag_filename):
    """
    Perform complete reconvergence analysis on a DAG.
    
    Args:
        dag_filename: Name of DAG JSON file in data/dag_output/
        
    Returns:
        Path to the generated reconvergence JSON file
    """
    dag_data = load_dag_json(dag_filename)
    G = build_dag_graph(dag_data)
    break_cycles(G)
    reconvergences = find_reconvergences(G)
    
    base = Path(dag_filename).stem
    output_filename = f"{base}_reconv.json"
    
    return save_reconvergence(reconvergences, output_filename)


def main():
    """CLI entry point for reconvergence analysis."""
    if len(sys.argv) != 2:
        print("Usage: python3 reconvergence.py <design>_dag.json")
        sys.exit(1)

    dag_file = sys.argv[1]
    
    try:
        output_path = analyze_reconvergence(dag_file)
        print(f"[✓] Reconvergence analysis completed: {output_path}")
    except FileNotFoundError as e:
        print(f"[ERROR] {e}")
        sys.exit(1)


if __name__ == '__main__':
    main()